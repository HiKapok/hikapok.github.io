<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Post Modern Paradigm</title>
  <icon>https://www.gravatar.com/avatar/633928e79a33db14690af625e0513ee6</icon>
  <subtitle>Kapok的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hikapok.github.io/"/>
  <updated>2018-03-01T02:51:59.141Z</updated>
  <id>https://hikapok.github.io/</id>
  
  <author>
    <name>Kapok</name>
    <email>wangchangan@yeah.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性回归和逻辑回归模型的基本假设</title>
    <link href="https://hikapok.github.io/2018/02/28/assumption-of-basic-ml/"/>
    <id>https://hikapok.github.io/2018/02/28/assumption-of-basic-ml/</id>
    <published>2018-02-28T12:41:59.000Z</published>
    <updated>2018-03-01T02:51:59.141Z</updated>
    
    <content type="html"><![CDATA[<p>对机器学习刚入门的同学很容易对一些基本概念混淆不清，尤其是当下Python中一些的工具包进一步降低了ML相关的实践。本文重点探讨一下统计学习理论中一些基础模型的应用假设。不过，首先我觉得有必要澄清一些基本概念。</p><h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a><strong>线性模型</strong></h1><p>何为线性模型？看似简单的问题却不一定能答得很好，初学者也容易被数学中线性这一概念所“误导”。</p><ul><li><strong>线性回归模型或线性分类器</strong></li></ul><p>在本文中这二者较为类似，以线性回归模型为例。给定一组随机抽取的样本$\mathbf{X_i} = X_{ij}$及其观测值$Y_i$，其中$i=1,…,N$，$j=1,…,p$，$p$是特征维数也是下面公式中非线性基函数的个数，线性回归模型定义为$$Y_i=\beta_0 + \beta_1\phi_1(X_{i1}) + \cdot + \beta_p\phi_p(X_{ip}) + \varepsilon_i$$<br>其中$\beta_j$是回归系数，可以用来评估每个分量在预测中的重要性，$\phi_j$是非线性基函数，$\varepsilon_t$是回归残差。这里的线性指的是回归系数是$\beta_j$线性的，同时预测值也是$\beta_j$的线性组合。</p><ul><li><strong>时间序列分析中的线性模型</strong></li></ul><p>在基于时间序列的分析和预测中，线性模型指的是某时刻随机变量的预测值是之前若干时刻的随机变量取值的线性函数，通俗来讲就是线性组合。比如随机过程中的一个叫作自回归(Autoregressive, AR)的模型就是一个经典的例子。以$AR(p)$来表示$p$阶自回归模型，则$AR(p)$可定义如下$$ X_t = c + \sum_{i=1}^p\varphi _iX_{t-i} + \varepsilon_t $$<br>其中$\varphi _1,…,\varphi _p$是模型参数，$\varepsilon_t$是残差满足独立高斯分布，$c$是常数项。这里的线性一词并不是指模型参数$\varphi _i$是线性的，这和线性回归模型是不一样的。</p><h1 id="线性回归模型的基本假设"><a href="#线性回归模型的基本假设" class="headerlink" title="线性回归模型的基本假设"></a><strong>线性回归模型的基本假设</strong></h1><p>现在进入本文正题，注意这里的讨论只针对基本的模型，一些假设可以通过如采样更多的数据，贝叶斯估计或其它正则化等方法进行弱化。</p><ul><li><em>i.i.d.</em>：样本随机独立抽样，也就是机器学习问题中最基本的独立同分布假设，训练样本和测试样本必须来自同一个潜在数据生成分布</li><li><em>解释分量之间不满足多重共线性，同时样本数不能太少</em>：这两点就能保证设计矩阵$\mathbf{X}$是满秩的（样本数要大于解释分量数），这样$\mathbf{X}^T\mathbf{X}$就有唯一的逆矩阵，这在线性回归的最小平方估计方法中非常重要，保证了回归系数的唯一性。</li><li><em>Error-Free</em>：样本$\mathbf{X_i}$采样过程中没有引入其他噪声，换句话说除了$\mathbf{X_i}$没有其它未知变量可以对$Y_i$对应的真实值产生确定性的影响，违反这一假设所引入的误差称为贝叶斯误差（Bayes error）</li><li><em>回归误差的条件均值为零</em>：这一点其实和上面的是一样的，同样意味着$\mathbf{X_i}$中包含了所有可以解释$Y_i$的分量，即$E[\varepsilon|\mathbf{X}] = 0$</li><li><em>线性假设</em>：预测真实值是回归系数的线性组合</li><li><em>回归误差的方差一致性</em>：回归误差在不同真实值处应具有相同的方差，与$\mathbf{X_i}$及$Y_i$无关，即$Var(\varepsilon|\mathbf{X})=\sigma^2$</li><li><em>回归误差的独立性</em>：承接上一条，$\varepsilon_i$之间应是相互独立的，$\varepsilon \sim N(0,\sigma^2)$，即不取决于是哪一个样本，至于零均值满足第四条自然能够得出</li></ul><h1 id="逻辑回归模型的基本假设"><a href="#逻辑回归模型的基本假设" class="headerlink" title="逻辑回归模型的基本假设"></a><strong>逻辑回归模型的基本假设</strong></h1><ul><li><em>i.i.d.</em>：同上</li><li><em>解释分量之间不满足多重共线性</em>：与上类似</li><li><em>对数几率和解释变量之间存在线性关系</em>：保证了回归系数是线性的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对机器学习刚入门的同学很容易对一些基本概念混淆不清，尤其是当下Python中一些的工具包进一步降低了ML相关的实践。本文重点探讨一下统计学习理论中一些基础模型的应用假设。不过，首先我觉得有必要澄清一些基本概念。&lt;/p&gt;
&lt;h1 id=&quot;线性模型&quot;&gt;&lt;a href=&quot;#线性模
      
    
    </summary>
    
      <category term="其它" scheme="https://hikapok.github.io/categories/others/"/>
    
    
      <category term="机器学习" scheme="https://hikapok.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="统计学习" scheme="https://hikapok.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用Google云平台搭建自己的深度学习工作站</title>
    <link href="https://hikapok.github.io/2018/01/19/intro-to-google-cloud/"/>
    <id>https://hikapok.github.io/2018/01/19/intro-to-google-cloud/</id>
    <published>2018-01-19T08:11:40.000Z</published>
    <updated>2018-01-19T11:00:06.214Z</updated>
    
    <content type="html"><![CDATA[<center> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="home.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> </center><p>Hello，大家好，最近正式启用了自己的博客，一直以来被各种任务缠身，始终没有养成记录自己学习的点滴的习惯。最近忙于申请实习拿到了两个还不错的offer，但无奈导师坚决不放人，于是打算接下来做一些别的事情，输出一些质量高的博文就是其中一项。</p><p>自己也算是入行计算机挺久了，一路走来有许多的感慨，包括个人的选择成长规划等等，过段时间也会进行一下总结分享给大家，希望大家能少走弯路。</p><p>第一篇博文专注于利用较少的资金建立一个可以用于深度学习调试的小工作站，从整体上来看谷歌云（Google Cloud Platform，GCP）在这价格、稳定性等方面有很大的优势，但是好像并没有多少介绍这方面的文章，作为新手来讲熟悉这些配置可能要花上一两天，这篇博文目的就是让新手在半小时内配置一个可用的深度学习环境，涉及配置的各种细节以及开发过程的各个方面，欢迎大家一起交流讨论。</p><p>原材料准备：</p><ul><li>支持<strong>VISA双币</strong>支付的信用卡一张</li><li>科学上网工具</li><li>PuTTY或其他终端工具</li><li>FileZilla或其他支持SFTP的客户端</li></ul><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a><strong>注册</strong></h1><p>首先你需要有一个Google账户，然后登陆<a href="https://cloud.google.com/" target="_blank" rel="external">https://cloud.google.com/</a>点击免费试用进行注册，填写基本信息和相关协议，账户类型选择个人，地址注意与信用卡账单地址一致，注册完成后信用卡账户会被预扣1美元，过会就会返还回来的。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h1><p>GCP对资源进行层次化的管理，方便结合Cloud Identity and Access Management (IAM)进行权限控制和统一配置，大到公司部门，小到具体某个虚拟机。对于个人用户来说，我们通常只需按照项目来组织我们的资源，项目可以说是我们创建、管理和监控资源、进行权限管理以及账单管理的基本单位了，新建账户默认包含一个初始项目，你也可以在控制台创建自己的新项目（个人用户默认最多10个项目），假设现在你已经配置好了自己的项目。</p><p>GCP有很多产品，包括大数据平台，存储和数据库服务，AI相关的API等，来帮助企业更快地创建优质的应用，但这些与本文无关，本文集中介绍如何利用Compute Engine Virtual Machines (VMs)来创建一个较为廉价的可供日常学习使用的机器学习/深度学习平台，合理利用这些资源可以让你尽可能少地为高昂的显卡资源自掏腰包。在正式开始之前有以下几点需要说明一下：</p><ul><li><p><strong>快捷入口</strong>：控制台左侧的Tab提供了GCP产品的一些快捷入口，本文主要涉及计算（Compute Engine）、网络（VPC网络）、产品（结算、IAM和管理）和存储（存储），可以先将这些入口钉一下固定在最上面方便一会直接点进去。</p></li><li><p><strong>预算</strong>：作为穷学生一枚本人比较关心钱的问题，虽然有Google赠送的300美元的现金券，我还是一开始就为整个项目（或者以整个计算账号为单位）制定了预算，超出时会自动提醒。费用是每天更新一次，结算周期是半个月，Google会在你花超过100美元或者距上次缴费超过一个月后自动扣款，费用详情可以在结算/交易里查询。</p></li><li><p><strong>配额</strong>：由于每个账号所拥有的资源都有一定的配额，并且GCP默认的GPU配额是0，因此我们需要进行配额调整的申请。具体在IAM和管理/配额里面操作，见图，点击指标下拉框搜索NVIDIA就会看到K80、P100等型号的GPU，把其他资源都反选掉，只保留GPU相关的服务。然后在下面列表里勾选你要选用的GPU型号（注意区域要和待会要创建的VMs所在区域一致），型号根据自己情况进行选择，本人选了K80（12GB内存可以满足我的日常使用），然后选择最上面的修改配额，在右侧弹窗里输入个人电话，目标调整数量以及申请理由，提交即可，我大概等了不到10分钟就调整好了。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="quato.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a><strong>创建虚拟机</strong></h1><p>创建VMs相关的操作都在Compute Engine菜单下，为了节省费用同时不至于太影响训练速度，我只设置了30GB的永久固态硬盘，然后又创建了120GB的永久机械硬盘挂载到实例上。如果你只希望用固态硬盘当做启动盘和数据盘，可以忽略创建磁盘这一步。</p><ul><li><p>创建磁盘<br>Compute Engine/磁盘：点击最上面创建磁盘，输入名称，选择与VMs一致的地区，类型设置为标准永久性磁盘，土豪可以选择SSD永久性磁盘，由于初次使用没有映像或者快照，因此来源类型选无（空白磁盘），待会我们在VMs里面进行格式化和分区操作。大小根据自己需求，建议可以稍大一些，一方面性能会好一些，另一方面各种数据集通常都要来回捣腾，因此最好要比预期数据量大一倍。</p></li><li><p>创建VMs<br>Compute Engine/VM实例：点创建，输入名称，这个名称会作为计算机名，选择与GPU和磁盘一致的区域，机器类型勾选自定义，我选的是4vCPU、8GB内存、1个K80 GPU，详单见图。启动磁盘选更改进行配置，选择Ubuntu 16.04 LTS操作系统镜像，如果我们之前对自己创建的虚拟机备份过映像这里可以直接选上，启动磁盘类型建议选择SSD大小自己配置，如果你之前有删除实例后剩下的启动磁盘想直接用可以在现有磁盘下面勾选，前提是里面要有操作系统。</p></li></ul><center> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="creatvm.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> </center><p>防火墙一栏勾上允许HTTP流量和HTTPS流量。下方磁盘那个Tab可以设置是否在删除实例时也把启动盘删除，这里我们在额外磁盘下面选择添加一项把之前创建的数据磁盘挂上来。管理Tab里面可以设置启动脚本，方便每次开机时进行系统更新、外部磁盘挂载等操作，这里我先没有设置，因为后面可以在弄好机器后在更改元数据里面重新设置。此外如果你不需要长时间训练模型那么可以开启抢占式VM，缺点就是随时都可能被终止（大约10%~20%的概率，实际由对应区域用量决定），即使由于整个区域用量较小没有被停掉24小时之后也会被终止，如果刚开启虚拟机10分钟之内被抢占是不收费的，需要注意的是抢占式VM的资源总量是有限的，也就是说并不是什么时候想用什么时候就有。</p><p>SSH密钥那个Tab里面我们需要配置一下以便使用其它终端工具对VM进行操作，GCP也自带基于浏览器的一种终端，感觉也不错，但是比较慢。终端工具根据自己习惯选择，这里以PuTTY为例进行配置。PuTTY带有一个密钥生成工具PuTTYgen，打开界面如下：</p><center> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="puttygen.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> </center><p>点击generate然后在空白区域来回晃几下鼠标就会生成一个ssh-rsa密钥，comment改成自己的用户名，VM会自动创建对应的账户，然后复制Public key（就是以ssh-rsa开头的最长的那个）粘贴到GCP刚才那个Tab里面，点创建等几分钟即可。接下来我们需要把刚才生成的密钥保存在同一个目录，保存private key的时候会提示设置密码。保存完毕后需要打开PuTTY新建一个session，这会VM实例应该也创建完毕，把外部ip地址填进来，然后在Connection-&gt;SSH-&gt;Auth属性页最下面把保存的private key加载进来，最后打开连接，安全提示选是然后就可以连接到虚拟机了。</p><p>如果你想直接用在线的SSH的话，直接在Compute Engine/VM实例里面点SSH，可以通过这个工具上传下载一些简单的文件之类的。</p><ul><li>设置数据磁盘</li></ul><p>数据磁盘本身是空白磁盘，虽然被接进来了，但必须进行格式化分区之后才可以挂载。以下命令帮你查看数据磁盘是不是真的连接进来了，并查看对应的设备号，我这里是sdb。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo fdisk –l</div></pre></td></tr></table></figure><p>接下来我们需要对空白磁盘进行分区，同样是使用fdisk命令进入一个交互式的环境，这个环境下所有的操作都不会立刻写进分区表，除非显式地通过w保存操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo fdisk /dev/sdb</div></pre></td></tr></table></figure><p>根据相应的快捷键提示可以很容易完成分区，我的整个磁盘只有一个分区，如果你的磁盘很大也可以分多个区，n新建分区，d删除分区，w保存分区表，q不保存直接退出。</p><p>如果你也是只分了一个区，那么你应该会得到一个名为sdb1的新设备，下面命令完成格式化，你也可以换成ntfs格式，这里使用linux格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.ext4 /dev/sdb1</div></pre></td></tr></table></figure><p>接下来我们在/media目录下新建一个挂载点（我这里名称为disk），把刚才格式化好的设备挂载进来：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /media/disk</div><div class="line">sudo mount /dev/sdb1 /media/disk</div></pre></td></tr></table></figure><p>如果你不想每次开机都手动挂载这个设备的话，可以设置上面说到的那个启动脚本，启动脚本的设置需要在关机状态下进行，待会你重启时记得设置：仍然是在Compute Engine/VM实例下面，点击VM的名称进入VM详情页面，点击最上面修改，往下拉找到自定义元数据，键设为startup-script，值设置为下面的脚本内容，然后点保存重启虚拟机。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line">mount /dev/sdb1 /media/disk</div></pre></td></tr></table></figure><p>同样的方法也可以设置shutdown-script，可以在关机或被抢占时保存模型或给自己发个邮件提醒之类的。</p><p>以上步骤完成后，我们还需要设置一下防火墙：</p><p>网络/VPC网络/防火墙规则：然后点击最上面创建防火墙规则，名称default-dev之类，目标选网络中的所有实例，来源 IP 地址范围填0.0.0.0/0，协议和端口填tcp:6000-6010;tcp:8888（这个根据日常开发用到的端口自己决定），其他保持默认。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><strong>环境配置</strong></h1><p>现在你已经有了一台至少4核8G内存附带一张K80显卡的机器了，接下来就是跟普通机器一样配置环境了。如果你已经很熟悉深度学习之类的环境配置，可以直接跳过这一部分。</p><p>我通常先会按照自己的使用习惯配置一下tmux、git和vim，装一些插件之类的。下面的命令可以帮你把一些大概率会用到的包提前装上，以免后续安装过程卡壳：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev valgrind cmake unrar gfortran python3-pip python3-dev python3-wheel swig git git-core htop</div></pre></td></tr></table></figure><p>建议日常的机器学习之类的调试训练都在虚拟环境下进行，虚拟环境配置可以参考下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-pip python-setuptools</div><div class="line">sudo pip install --upgrade pip</div><div class="line">sudo pip install virtualenv</div><div class="line">curl -L https://raw.github.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</div></pre></td></tr></table></figure><p>设置虚拟环境对应的环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim ~/.bash_profile</div></pre></td></tr></table></figure><p>在文件最后加上下面这些内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=<span class="string">"/home/yourname/.pyenv/bin:<span class="variable">$PATH</span>"</span></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span></div></pre></td></tr></table></figure><p>生效更改然后安装python 3.5.2：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> ~/.bash_profile</div><div class="line">pyenv install 3.5.2</div></pre></td></tr></table></figure><p>注意把默认的python设置为系统对应的python版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看可用的python版本，注意默认版本</span></div><div class="line">pyenv versions</div><div class="line"><span class="comment"># 把默认版本设为系统自带的python版本</span></div><div class="line">pyenv global system</div></pre></td></tr></table></figure><p>在当前目录下创建一个名为pyenv35的虚拟环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv -p .pyenv/versions/3.5.2/bin/python3.5 pyenv35</div></pre></td></tr></table></figure><p>激活刚创建的虚拟环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> pyenv35/bin/activate</div></pre></td></tr></table></figure><p>安装常用机器学习包（这个根据自己的需求来）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv35/bin/pip3.5 install numpy scipy matplotlib pandas seaborn sklearn lightgbm xgboost tqdm</div></pre></td></tr></table></figure><p>安装CUDA运行时环境</p><p>首先确认一下系统应该至少没有安装除nvidia-common之外的任何nvidia的包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dpkg -l | grep -i nvidia</div></pre></td></tr></table></figure><p>否则使用以下命令删除多余的包及配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove --purge name_of_ package</div><div class="line">sudo apt-get autoremove</div></pre></td></tr></table></figure><p>然后我们需要下载CUDA的安装包和cuDNN：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo wget http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_8.0.61-1_amd64.deb</div><div class="line">sudo wget http://developer.download.nvidia.com/compute/redist/cudnn/v6.0/cudnn-8.0-linux-x64-v6.0.tgz</div><div class="line">sudo wget https://developer.nvidia.com/compute/cuda/8.0/Prod2/patches/2/cuda-repo-ubuntu1604-8-0-local-cublas-performance-update_8.0.61-1_amd64-deb</div></pre></td></tr></table></figure><p>接下来安装驱动和运行时：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo dpkg -i cuda-repo-ubuntu1604_8.0.61-1_amd64.deb</div><div class="line">sudo dpkg -i cuda-repo-ubuntu1604-8-0-local-cublas-performance-update_8.0.61-1_amd64.deb</div><div class="line">sudo apt-get update</div></pre></td></tr></table></figure><p>查看可用的CUDA运行时版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-cache policy cuda</div></pre></td></tr></table></figure><p>安装CUDA8.0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install cuda=8.0.61-1</div></pre></td></tr></table></figure><p>添加源并更新到最新驱动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</div></pre></td></tr></table></figure><p>这里记得需要敲回车键确认添加源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get upgrade</div><div class="line">sudo reboot</div></pre></td></tr></table></figure><p>安装cuDNN</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -xvf cudnn-8.0-linux-x64-v6.0.tgz</div><div class="line">sudo cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include</div><div class="line">sudo cp cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64</div><div class="line">sudo chmod a+r /usr/<span class="built_in">local</span>/cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/lib64/libcudnn*</div></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim ~/.bashrc</div></pre></td></tr></table></figure><p>在文件最后添加下面内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">"<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64"</span></div><div class="line"><span class="built_in">export</span> CUDA_HOME=/usr/<span class="built_in">local</span>/cuda</div><div class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$CUDA_HOME</span>/bin:<span class="variable">$PATH</span>"</span></div></pre></td></tr></table></figure><p>生效更改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure><p>最后敲nvidia-smi确认驱动安装成功</p><h1 id="安装深度学习工具包"><a href="#安装深度学习工具包" class="headerlink" title="安装深度学习工具包"></a><strong>安装深度学习工具包</strong></h1><p>安装bazel、tensorflow-gpu、PyTorch、MxNet</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install openjdk-8-jdk</div><div class="line"><span class="built_in">echo</span> <span class="string">"deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8"</span> | sudo tee /etc/apt/sources.list.d/bazel.list</div><div class="line">curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -</div><div class="line">sudo apt-get update &amp;&amp; sudo apt-get install bazel</div></pre></td></tr></table></figure><p>先进入虚拟环境，然后执行以下命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv35/bin/pip3.5 install opencv-python tensorflow-gpu http://download.pytorch.org/whl/cu80/torch-0.3.0.post4-cp35-cp35m-linux_x86_64.whl torchvision mxnet-cu80==1.0.0</div></pre></td></tr></table></figure><p>配置远程jupyter notebook</p><p>仍然是在虚拟环境下，安装notebook:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv35/bin/pip3.5 install jupyter notebook</div></pre></td></tr></table></figure><p>进入python交互式环境，生成hash密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</div><div class="line">passwd()</div></pre></td></tr></table></figure><p>输入密码并记下形如’sha1:daa96*06c24059c807b08’的字串。</p><p>在bash里输入下面的命令生成notebook配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jupyter notebook --generate-config</div></pre></td></tr></table></figure><p>编辑配置文件，设置密码和权限等：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim .jupyter/jupyter_notebook_config.py</div></pre></td></tr></table></figure><p>设置以下几项并保存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c.NotebookApp.ip = <span class="string">'*'</span></div><div class="line">c.NotebookApp.password = u<span class="string">'sha1:daa96*06c24059c807b08'</span></div><div class="line">c.NotebookApp.open_browser = False</div><div class="line">c.NotebookApp.port = 8888</div></pre></td></tr></table></figure><p>执行jupyter notebook打开notebook，然后在本地浏览器打开<a href="http://yourip:8888" target="_blank" rel="external">http://yourip:8888</a>，如果正常的话，输入密码就可以使用了。如果有问题可以确认一下防火墙。</p><p>现在是时候去网上找一些测试代码来确认安装过程的正确性了。</p><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a><strong>文件共享</strong></h1><p>本想按照往常一样安装samba将虚拟机的磁盘映射到windows系统网络驱动器来传文件，但是搞了半天老是连不通，有知道解决方案的知友欢迎留言。因此目前只能采用FileZilla通过SFTP给VMs传文件的方式。操作如下：</p><p>打开FileZilla-&gt;文件-&gt;站点管理器-&gt;新站点：主机填VM的外部ip，协议选择SFTP，登录类型选择密码文件，然后把之前用PuTTY生成的私钥加载进来，高级选项卡里面可以设置本地目录和远程目录。最后点连接就行了，如果有问题的话可以检查一下远程目录的权限，我试了一下传输速度还挺快。</p><p>还有一点，日常的开发工作除了用notebook远程连接外，还可以在SublimeText下面使用SFTP的插件，配置过程跟上面文件传输的配置类似。</p><p>好了现在就应该都大功告成了，最后别忘了为配置好的系统制作映像，以便将来重新安装：</p><p>Compute Engine-&gt;映像-&gt;创建映像。</p><p>最近会抽空更新几篇机器学习相关的文章，欢迎大家关注，也欢迎大家讨论交流、指出问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt; &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
          
      
    
    </summary>
    
      <category term="其它" scheme="https://hikapok.github.io/categories/others/"/>
    
    
      <category term="机器学习" scheme="https://hikapok.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://hikapok.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="环境配置" scheme="https://hikapok.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hikapok.github.io/2017/10/16/hello-world/"/>
    <id>https://hikapok.github.io/2017/10/16/hello-world/</id>
    <published>2017-10-16T08:42:43.371Z</published>
    <updated>2017-10-02T15:52:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
