{"meta":{"title":"Post Modern Paradigm","subtitle":"Kapok的技术博客","description":"C++、机器学习、计算机视觉","author":"Kapok","url":"https://hikapok.github.io"},"pages":[{"title":"","date":"2018-01-19T08:09:21.831Z","updated":"2017-10-11T04:34:56.000Z","comments":false,"path":"categories/index.html","permalink":"https://hikapok.github.io/categories/index.html","excerpt":"","text":""},{"title":"Post Modern Paradigm","date":"2017-10-14T15:38:37.000Z","updated":"2017-10-15T15:44:34.000Z","comments":true,"path":"about/index.html","permalink":"https://hikapok.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-19T08:09:55.338Z","updated":"2017-10-11T04:34:12.000Z","comments":false,"path":"tags/index.html","permalink":"https://hikapok.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Tensorflow是如何注册和调用C++ New Op的","slug":"how-new-op-works","date":"2018-03-02T02:52:15.000Z","updated":"2018-03-02T03:47:53.096Z","comments":true,"path":"2018/03/02/how-new-op-works/","link":"","permalink":"https://hikapok.github.io/2018/03/02/how-new-op-works/","excerpt":"","text":"寒假回来想起来挖的坑，但好像并没有特别好的主题可以写，更不用说实习招聘近在眼前了，于是打算先扩展一下之前在知乎上的两个回答。 本文主要介绍动态链接的C++ New Op是如何被注册进来，又如何被Python代码调用的，也算是给自己的一个交代，毕竟本人一直不太喜欢high-level的API。本文大致分为三个模块：注册Ops，注册Kernel，调用Ops。 Ops的注册过程先说一下OpRegistrationData这个东西，这个类的对象由全局注册器Registry负责分配，作用简单来说就是保存OpDef和OpShapeInferenceFn函数，前者保存有Op的各种具体信息，会由OpDefBuilder在最后的解析参数时（成员函数Finalize）放进来，后者在SetShapeFn传进来（由Wrapper转发），所谓注册就是将op name和OpRegistrationData关联起来，具体来说放进hashmap。1mutable std::unordered_map&lt;string, const OpRegistrationData*&gt; registry_; 还得先说一下OpDefBuilder这个类，OpDefBuilder会负责接收Op的各种属性和参数定义（就是REGISTER_OP时指定的，见下），最后统一解析（注意只是解析并不保证合法性之类的）并转给OpRegistrationData这个类（包括ShapeFn）。 我们自己注册op都会通过下面这个宏定义：123456789REGISTER_OP(\"YourOp\") .Attr(\"T: &#123;float&#125;\") .Input(\"logits: T\") .Input(\"Labels: T\") .Output(\"loss: T\") .SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) &#123; c-&gt;set_output(0, c-&gt;MakeShape(&#123;1&#125;)); return Status::OK(); &#125;); 细节都在REGISTER_OP那个宏定义里面，简化如下：1static OpDefBuilderReceiver register_op = OpDefBuilderWrapper('YourOp') 其中OpDefBuilderWrapper内部保存有一个OpDefBuilder成员变量，你所有对REGISTER_OP宏连续调用的操作包括op的名字最后都会一股脑转发给前面那个唯一的OpDefBuilder变量，而OpDefBuilderReceiver则拿过来BuilderWrapper交给一个负责管理所有Op注册的Registry，Registry暴露Register方法给op们注册，把官方的example摘过来示意一下：123456//Example registration: OpRegistry::Global()-&gt;Register( [](OpRegistrationData* op_reg_data)-&gt;Status &#123; // Populate *op_reg_data here. return Status::OK(); &#125;); （先解释下：OpRegistry::Global()简单的单例模式，返回OpRegistry的全局唯一实例，当然这里必须要感谢下新标准对static线程安全的保证。） 在那个lambda里面你就可以做任何想做的事情了，比如就像OpDefBuilderReceiver一样把BuilderWrapper拿进来，然后把wrapper去掉取出OpDefBuilder，看到上面lambda里面那个op_reg_data没，对这就是之前提到的将解析好参数及shapefn传到OpRegistrationData里，最后Register拿到op的name和OpRegistrationData组成pair放进hashmap完成注册，同时会做一些合法性检查的事情。如下：1234OpRegistry::Global()-&gt;Register( [wrapper](OpRegistrationData* op_reg_data) -&gt; Status &#123; return wrapper.builder().Finalize(op_reg_data); &#125;); 其实到这里真正的注册并不一定会发生，下面会详细说。 Kernel的注册过程与Ops的注册类似，也是有一个叫作KernelDefBuilder的wrapper，内部保存有KernelDef的一个指针，用于设置各种属性，最后调用Build函数可返回该指针并清空Builder，Kernel的注册主要是通过下面这个宏来实现的：123REGISTER_KERNEL_BUILDER( \\ Name(\"PsRoiAlignGrad\").Device(DEVICE_GPU).TypeConstraint&lt;float&gt;(\"T\"), \\ PSROIAlignGradOp&lt;GPUDevice, float&gt;); 其中Name是KernelDefBuilder的一个派生类，Name(“KernelName”)会首先创建一个KernelDefBuilder同时设置设置kernel名称，每次调用这种setter函数就会返回Builder自身从而支持连续调用，然后是设置Device，最后添加值float到属性T中。 123456class Name : public KernelDefBuilder &#123; public: // For system kernels, we ignore selective registration and // unconditionally register the kernel. explicit Name(const char* op) : KernelDefBuilder(op) &#123;&#125;&#125;; REGISTER_KERNEL_BUILDER宏里面就是一些trick，实质是创建一个名称唯一的类型为OpKernelRegistrar的全局静态变量，如果你有兴趣可以看一下： 12345678910111213141516171819#define REGISTER_KERNEL_BUILDER(kernel_builder, ...) \\ REGISTER_KERNEL_BUILDER_UNIQ_HELPER(__COUNTER__, kernel_builder, __VA_ARGS__)#define REGISTER_KERNEL_BUILDER_UNIQ_HELPER(ctr, kernel_builder, ...) \\ REGISTER_KERNEL_BUILDER_UNIQ(ctr, kernel_builder, __VA_ARGS__)#define REGISTER_KERNEL_BUILDER_UNIQ(ctr, kernel_builder, ...) \\ constexpr bool should_register_##ctr##__flag = \\ SHOULD_REGISTER_OP_KERNEL(#__VA_ARGS__); \\ static ::tensorflow::kernel_factory::OpKernelRegistrar \\ registrar__body__##ctr##__object( \\ should_register_##ctr##__flag \\ ? ::tensorflow::register_kernel::kernel_builder.Build() \\ : nullptr, \\ #__VA_ARGS__, \\ [](::tensorflow::OpKernelConstruction* context) \\ -&gt; ::tensorflow::OpKernel* &#123; \\ return new __VA_ARGS__(context); \\ &#125;); OpKernelRegistrar静态变量的构造需要三个参数，如下所示，第一个是KernelDef，第二个是定义Kernel的类名，第三个是创建kernel对象的函数，其实后面就可以知道这三个参数都会被包装到KernelRegistration这个结构体里，然后作为Kernel注册表的值。因此这个宏会首先调用KernelDefBuilder的Build函数获得对应的KernelDef；然后获取用于创建这个Kernel的C++类名称（这个类是继承自OpKernel的）；最后包装一个factory函数用来接收传进来的OpKernelConstruction*，创建对应的Kernel类对象，并返回其指针。1234567891011class OpKernelRegistrar &#123; public: typedef OpKernel* (*Factory)(OpKernelConstruction*); OpKernelRegistrar(const KernelDef* kernel_def, StringPiece kernel_class_name, Factory factory) &#123; if (kernel_def != nullptr) &#123; InitInternal(kernel_def, kernel_class_name, factory); &#125; &#125;&#125;; 这里是InitInternal的细节12345678910111213void OpKernelRegistrar::InitInternal(const KernelDef* kernel_def, StringPiece kernel_class_name, Factory factory) &#123; // See comments in register_kernel::Name in header for info on _no_register. if (kernel_def-&gt;op() != \"_no_register\") &#123; const string key = Key(kernel_def-&gt;op(), DeviceType(kernel_def-&gt;device_type()), kernel_def-&gt;label()); GlobalKernelRegistryTyped()-&gt;insert(std::make_pair( key, KernelRegistration(*kernel_def, kernel_class_name, factory))); &#125; delete kernel_def;&#125; 可以看到OpKernelRegistrar这个类主要是负责根据传进来的KernelDef和KernelFactory，首先依据一定规则生成一个适当的key，并插入到一个全局唯一的Kernel注册表里，注册表当然是一个map但是值得注意的是它是multimap因此支持一个键对应多个kernel副本。1typedef std::unordered_multimap&lt;string, KernelRegistration&gt; KernelRegistry; OpKernel的创建与调用如果你还记得的话，前面还有一个全局的OpRegistry，这样根据NodeDef里的Op名称就可以获得Op对应的信息，再结合设备类型也就可以获得Kernel对应的信息了，而NodeDef是在Python创建Operation之前创建的，可以看这里create_op，后面会提到调用这个函数的地方。 然后就可以根据一个NodeDef和当前的设备类型在运行时创建一个OpKernel了，每个被创建的OpKernel都会被自动地管理生命周期。在Device类中会有一个OpSegment对象，OpSegment会管理一个sessions中用到的kernel，根据情况来决定是创建新的还是复用之前的OpKernel，具体来说是有两个嵌套的hashmap，第一个将session handle映射到一个KernelMap，然后在KernelMap就可以去查找是否有对应Op名的OpKernel，如果没有就调用一个create_fn函数进行创建。 那么问题来了，这背后的原动力在哪？事实上Session在第一次为某个Node创建Executor的时候这一切就发生了（后面会再说到Executor的）：DirectSession::GetOrCreateExecutors，更直接地可以看查找失败后第一次创建Executor的地方，代码片段如下：123456789101112131415161718192021222324LocalExecutorParams params;params.device = device;params.function_library = lib;auto opseg = device-&gt;op_segment();params.create_kernel = [this, lib, opseg](const NodeDef&amp; ndef, OpKernel** kernel) &#123; // We do not share the kernel via the OpSegment if the node is // stateless, or a function. // NOTE(mrry): We must not share function kernels (implemented // using `CallOp`) between subgraphs, because `CallOp::handle_` // is tied to a particular subgraph. Even if the function itself // is stateful, the `CallOp` that invokes it is not. if (!lib-&gt;IsStateful(ndef.op()) || lib-&gt;GetFunctionLibraryDefinition()-&gt;Find(ndef.op()) != nullptr) &#123; return lib-&gt;CreateKernel(ndef, kernel); &#125; auto create_fn = [lib, &amp;ndef](OpKernel** kernel) &#123; return lib-&gt;CreateKernel(ndef, kernel); &#125;; // Kernels created for subgraph nodes need to be cached. On // cache miss, create_fn() is invoked to create a kernel based // on the function library here + global op registry. return opseg-&gt;FindOrCreate(session_handle_, ndef.name(), kernel, create_fn);&#125;; 可以看到取出OpSegment，构造create_fn并调用FindOrCreate的过程。其中create_fn内部调用的FunctionLibraryRuntime的CreateKernel函数可以看这里：FunctionLibraryRuntimeImpl::CreateKernel，再往下CreateNonCachedKernel： 12345678Status CreateNonCachedKernel(Device* device, FunctionLibraryRuntime* flib, const NodeDef&amp; ndef, int graph_def_version, OpKernel** kernel) &#123; const auto device_type = DeviceType(device-&gt;attributes().device_type()); auto allocator = device-&gt;GetAllocator(AllocatorAttributes()); return CreateOpKernel(device_type, device, allocator, flib, ndef, graph_def_version, kernel);&#125; 看到了CreateOpKernel的调用，这下总算回到了我们最开始的地方CreateOpKernel： 1234Status CreateOpKernel(DeviceType device_type, DeviceBase* device, Allocator* allocator, FunctionLibraryRuntime* flib, const NodeDef&amp; node_def, int graph_def_version, OpKernel** kernel) 这个核心函数主要是做一下以下几件事情：根据node_def取出op名，去查OpRegistry，并与node_def的信息进行校验，比如接口是否一致，node_def中是否包含所有op_def中的信息等，然后根据device_type和op名去查KernelRegistry获取KernelRegistration，就是map中的值，包含之前提到的三项接着是确定输入输出类型及其存储位置，最后是创建一个OpKernelConstruction对象，并传给Kernel的factory函数函数，这就到了用户自己写的函数这边了： 12345// Everything needed for OpKernel construction.OpKernelConstruction context( device_type, device, allocator, &amp;node_def, op_def, flib, inputs, input_memory_types, outputs, output_memory_types, graph_def_version, &amp;s);*kernel = (*registration-&gt;factory)(&amp;context); Kernel创建完了，那么它什么时候被执行呢？前面说到第一次创建executor的时候会创建OpKernel，其实每次Session调用Run的时候最终也是转到executor这边来执行的，包括根据当前的运行时环境创建OpKernelContext以及OpKernel::Compute的调用： 12345// Synchronous computes.OpKernelContext ctx(&amp;params, item.num_outputs);nodestats::SetOpStart(stats);device-&gt;Compute(CHECK_NOTNULL(op_kernel), &amp;ctx);nodestats::SetOpEnd(stats); 其中device-&gt;Compute这一步通过查看基类的实现就大概能知道所有细节了Device::Compute： 1234567// Performs the actual compute function.//// Subclasses may override this function if they wish to perform// some initialization before each compute.virtual void Compute(OpKernel* op_kernel, OpKernelContext* context) &#123; op_kernel-&gt;Compute(context);&#125; 可以发现，我们写的Compute方法在这里就被调用了。至此故事好像可以告一段落了，不过说了半天好像一直在C++这边啊，那Python代码怎么调用的呢？ 注册Ops和Kernel后传根据上面REGISTER_KERNEL_BUILDER所展开的两段程序很容易就判断出如果动态库被加载进来的话，Kernel就会自动完成注册，这跟Ops的注册基本是一样的，不同之处在于动态链接进来的Ops会在加载库之前设置延迟注册的标记，并添加一个Watcher，然后手动调用注册，这主要是为了通过Watcher获取注册过程中从OpRegistrationData（就是注册表的值）中取出的OpDef，这一点可以在后面的LoadLibrary中看到。这个过程很重要，通过获得的OpDef组成的OpList并序列化后，Python端就可以解析出这些OpDef，同时调用C++这边利用这些OpDef生成对应的ApiDef，二者结合就可以动态生成定义这个Op的Python代码，然后返回到Python端执行这些代码，注意这些代码的执行并不包括创建Op并添加到Graph这个过程，只包括定义相关代码段的函数，下面是从Python端load_op_library一直到生成Python代码的过程：load_op_library-&gt;GetPythonWrappers-&gt;GetPythonOps-&gt;GetPythonOp-&gt;GenPythonOp::Code()。还有从OpList生成ApiDef的地方ApiDefMap::ApiDefMap(const OpList&amp; op_list)。如果你有兴趣的话可以去看一下我之前写的一个Op自动生成的代码，我附在了本文最后，生成代码中的apply_op就是添加Op到Graph的代码，可以看这里apply_op，这个函数的最后面就是前面提到的调用Graph的create_op。 下面是LoadLibrary的代码段，可以对照一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Status LoadLibrary(const char* library_filename, void** result, const void** buf, size_t* len) &#123; static mutex mu; static std::unordered_map&lt;string, Library&gt; loaded_libs; Env* env = Env::Default(); Library library; std::unordered_set&lt;string&gt; seen_op_names; &#123; mutex_lock lock(mu); if (loaded_libs.find(library_filename) != loaded_libs.end()) &#123; library = loaded_libs[library_filename]; &#125; else &#123; Status s = OpRegistry::Global()-&gt;ProcessRegistrations(); if (!s.ok()) &#123; return s; &#125; TF_RETURN_IF_ERROR(OpRegistry::Global()-&gt;SetWatcher( [&amp;library, &amp;seen_op_names](const Status&amp; s, const OpDef&amp; opdef) -&gt; Status &#123; if (errors::IsAlreadyExists(s)) &#123; if (seen_op_names.find(opdef.name()) == seen_op_names.end()) &#123; // Over writing a registration of an op not in this custom op // library. Treat this as not an error. return Status::OK(); &#125; &#125; if (s.ok()) &#123; *library.op_list.add_op() = opdef; seen_op_names.insert(opdef.name()); &#125; return s; &#125;)); OpRegistry::Global()-&gt;DeferRegistrations(); s = env-&gt;LoadLibrary(library_filename, &amp;library.handle); if (s.ok()) &#123; s = OpRegistry::Global()-&gt;ProcessRegistrations(); &#125; if (!s.ok()) &#123; OpRegistry::Global()-&gt;ClearDeferredRegistrations(); TF_RETURN_IF_ERROR(OpRegistry::Global()-&gt;SetWatcher(nullptr)); return s; &#125; TF_RETURN_IF_ERROR(OpRegistry::Global()-&gt;SetWatcher(nullptr)); loaded_libs[library_filename] = library; &#125; &#125; string str; library.op_list.SerializeToString(&amp;str); char* str_buf = reinterpret_cast&lt;char*&gt;(port::Malloc(str.length())); memcpy(str_buf, str.data(), str.length()); *buf = str_buf; *len = str.length(); *result = library.handle; return Status::OK();&#125; 自动生成的Python代码，这里是对应的C++ Op：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165\"\"\"Python wrappers around TensorFlow ops.This file is MACHINE GENERATED! Do not edit.\"\"\"import collections as _collectionsfrom tensorflow.core.framework import op_def_pb2 as _op_def_pb2# Needed to trigger the call to _set_call_cpp_shape_fn.from tensorflow.python.framework import common_shapes as _common_shapesfrom tensorflow.python.framework import op_def_registry as _op_def_registryfrom tensorflow.python.framework import ops as _opsfrom tensorflow.python.framework import op_def_library as _op_def_libraryfrom tensorflow.python.util.tf_export import tf_export_ps_roi_align_outputs = [\"pooled_features\", \"pooled_index\"]_PsRoiAlignOutput = _collections.namedtuple( \"PsRoiAlign\", _ps_roi_align_outputs)@tf_export('ps_roi_align')def ps_roi_align(inputs, rois, grid_dim_width, grid_dim_height, name=None): r\"\"\" PsRoiAlign is a new PsRoiPooling method without align problems. The input rois to be pooled must in format [center_y, center_x, h, w] and each element must be in range [0, 1.]. The caller must make sure that all rois is valid (has a intersect region (one pixel at least) with the window [0.5, 0.5, 1., 1.]). Args: inputs: A `Tensor`. Must be one of the following types: `float32`. rois: A `Tensor`. Must have the same type as `inputs`. grid_dim_width: An `int`. grid_dim_height: An `int`. name: A name for the operation (optional). Returns: A tuple of `Tensor` objects (pooled_features, pooled_index). pooled_features: A `Tensor`. Has the same type as `inputs`. pooled_index: A `Tensor` of type `int32`. \"\"\" _result = _op_def_lib.apply_op(\"PsRoiAlign\", inputs=inputs, rois=rois, grid_dim_width=grid_dim_width, grid_dim_height=grid_dim_height, name=name) _result = _PsRoiAlignOutput._make(_result) return _result_ops.RegisterShape(\"PsRoiAlign\")(None)@tf_export('ps_roi_align_grad')def ps_roi_align_grad(inputs, rois, pooled_features_grad, pooled_index, grid_dim_width, grid_dim_height, name=None): r\"\"\" PsRoiAlignGrad is the Gradient op of PsRoiAlign. The input rois to be pooled must in format [center_y, center_x, h, w] and each element must be in range [0, 1.]. The caller must make sure that all rois is valid (has a intersect region (one pixel at least) with the window [0.5, 0.5, 1., 1.]). Args: inputs: A `Tensor`. Must be one of the following types: `float32`. rois: A `Tensor`. Must have the same type as `inputs`. pooled_features_grad: A `Tensor`. Must have the same type as `inputs`. pooled_index: A `Tensor` of type `int32`. grid_dim_width: An `int`. grid_dim_height: An `int`. name: A name for the operation (optional). Returns: A `Tensor`. Has the same type as `inputs`. \"\"\" _result = _op_def_lib.apply_op(\"PsRoiAlignGrad\", inputs=inputs, rois=rois, pooled_features_grad=pooled_features_grad, pooled_index=pooled_index, grid_dim_width=grid_dim_width, grid_dim_height=grid_dim_height, name=name) return _result_ops.RegisterShape(\"PsRoiAlignGrad\")(None)def _InitOpDefLibrary(op_list_proto_bytes): op_list = _op_def_pb2.OpList() op_list.ParseFromString(op_list_proto_bytes) _op_def_registry.register_op_list(op_list) op_def_lib = _op_def_library.OpDefLibrary() op_def_lib.add_op_list(op_list) return op_def_lib# op &#123;# name: \"PsRoiAlign\"# input_arg &#123;# name: \"inputs\"# type_attr: \"T\"# &#125;# input_arg &#123;# name: \"rois\"# type_attr: \"T\"# &#125;# output_arg &#123;# name: \"pooled_features\"# type_attr: \"T\"# &#125;# output_arg &#123;# name: \"pooled_index\"# type: DT_INT32# &#125;# attr &#123;# name: \"T\"# type: \"type\"# allowed_values &#123;# list &#123;# type: DT_FLOAT# &#125;# &#125;# &#125;# attr &#123;# name: \"grid_dim_width\"# type: \"int\"# &#125;# attr &#123;# name: \"grid_dim_height\"# type: \"int\"# &#125;# &#125;# op &#123;# name: \"PsRoiAlignGrad\"# input_arg &#123;# name: \"inputs\"# type_attr: \"T\"# &#125;# input_arg &#123;# name: \"rois\"# type_attr: \"T\"# &#125;# input_arg &#123;# name: \"pooled_features_grad\"# type_attr: \"T\"# &#125;# input_arg &#123;# name: \"pooled_index\"# type: DT_INT32# &#125;# output_arg &#123;# name: \"grad_output\"# type_attr: \"T\"# &#125;# attr &#123;# name: \"T\"# type: \"type\"# allowed_values &#123;# list &#123;# type: DT_FLOAT# &#125;# &#125;# &#125;# attr &#123;# name: \"grid_dim_width\"# type: \"int\"# &#125;# attr &#123;# name: \"grid_dim_height\"# type: \"int\"# &#125;# &#125;_op_def_lib = _InitOpDefLibrary(b\"\\\\n\\\\215\\\\001\\\\n\\\\nPsRoiAlign\\\\022\\\\013\\\\n\\\\006inputs\\\\\"\\\\001T\\\\022\\\\t\\\\n\\\\004rois\\\\\"\\\\001T\\\\032\\\\024\\\\n\\\\017pooled_features\\\\\"\\\\001T\\\\032\\\\020\\\\n\\\\014pooled_index\\\\030\\\\003\\\\\"\\\\020\\\\n\\\\001T\\\\022\\\\004type:\\\\005\\\\n\\\\0032\\\\001\\\\001\\\\\"\\\\025\\\\n\\\\016grid_dim_width\\\\022\\\\003int\\\\\"\\\\026\\\\n\\\\017grid_dim_height\\\\022\\\\003int\\\\n\\\\250\\\\001\\\\n\\\\016PsRoiAlignGrad\\\\022\\\\013\\\\n\\\\006inputs\\\\\"\\\\001T\\\\022\\\\t\\\\n\\\\004rois\\\\\"\\\\001T\\\\022\\\\031\\\\n\\\\024pooled_features_grad\\\\\"\\\\001T\\\\022\\\\020\\\\n\\\\014pooled_index\\\\030\\\\003\\\\032\\\\020\\\\n\\\\013grad_output\\\\\"\\\\001T\\\\\"\\\\020\\\\n\\\\001T\\\\022\\\\004type:\\\\005\\\\n\\\\0032\\\\001\\\\001\\\\\"\\\\025\\\\n\\\\016grid_dim_width\\\\022\\\\003int\\\\\"\\\\026\\\\n\\\\017grid_dim_height\\\\022\\\\003int\")","categories":[{"name":"深度学习","slug":"deeplearning","permalink":"https://hikapok.github.io/categories/deeplearning/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://hikapok.github.io/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hikapok.github.io/tags/深度学习/"},{"name":"C++","slug":"C","permalink":"https://hikapok.github.io/tags/C/"}]},{"title":"使用Tensorflow C++ API自定义操作","slug":"write-cpp-op","date":"2018-03-01T02:57:28.000Z","updated":"2018-03-02T04:05:08.747Z","comments":true,"path":"2018/03/01/write-cpp-op/","link":"","permalink":"https://hikapok.github.io/2018/03/01/write-cpp-op/","excerpt":"","text":"Tensorflow提供了大量的基本操作使得我们能够任意组合来实现我们需要的复杂操作，但有时候我们需要的操作不太容易通过这些基本操作来组合，或者复杂的组合方式带来严重的性能开销，这时我们可能会考虑去使用py_func来包装Python函数借助Numpy来实现，但性能方面可能也无法达到满意的程度，更不要说有些操作不适合向量化的写法，这个时候用C++ API来实现自己的一个操作可能会是更好的选择。 总得来说，我们可以通过静态链接或动态连接的方式来添加我们自定义的操作，前者需要你能成功从源码编译安装Tensorflow（Installing TensorFlow from Sources），后者只需要安装Tensorflow的Python包即可，不过后者有一个缺点就是可用的C++ API是有限的，如果你需要一些别的接口可能要自己去找相关的头文件然后手动添加进来，如果头文件数目很多这就是一件很头疼的事情了，但优点也是很明显，一是简单，二是不用强制要求使用你操作的人也要从源码编译安装Tensorflow。下面主要以动态链接的添加为例进行叙述，对静态链接添加的方式也会有涉及，二者基本上是一样的。另外，本文主要注重实践部分，如果你需要一些更详细的标准化说明，可以去参考官方的Tutorial：Adding a New Op，一些比如Ops注册的属性说明以及如何保持Ops属性的后向兼容性等会更加详细。 另外如果你对Tensorflow注册Ops和Kernel的过程或者它们是如何被Python代码调用的感兴趣，可以阅读我之前写的一篇文章Tensorflow是如何注册和调用C++ New Op的。如果你想学习一下官方Ops是怎么写的，我推荐从Bias_Op来开始学习，因为这个Op写的还是很清晰然后对初学者不会有太多的阻碍，当然也可以参考我最近写的PSROIAlign。这里还必须要推荐一个利器SourceInsight简直是阅读这种开源代码的法宝。 先总结官方给的自定义op的标准流程：注册Op，实现Op，创建python接口，实现Op梯度计算（如果不需要求导也可以直接pass掉，实现可以在python端也可以用py_func去包装其他python函数，也可以再写一个C++ Op来专门计算梯度），测试。 注册Op注册Op相当于是一个声明的过程。Op是tensorflow中非常重要的概念，一个Op接收一个或多个输入张量，然后经过某种运算，产生其他零个或多个tensor，然后这些tensor又可以被其他Op使用。类似于C++中我们定义变量需要知道数据类型，字节数等信息一样，创建一个Op同样需要一些额外信息包括attributes（输入输出类型以及合法取值等，也可以看作是Op的输入但是不同于输入的是属性永远是常量，其值在Op被添加到图中时被设置，并且是一直放在CPU上的）以及输入输出列表，还可以直接加Doc，具体信息是我们在REGISTER_OP时指定的，REGISTER_OP是一个宏，其内部实现是一个wrapper利用了C++中的常用伎俩chaining调用实现，所有你在这添加的信息都会以另一种形式出现在动态生成的Python代码中。有一点需要注意，在C++这边Ops的名称必须是CamelCase类型的，在Python那一边会自动被转换成Python风格的snake_case类型。 注册这个地方还有一个SetShapeFn需要说一下，主要作用是检查输入的shape并指定输出的shape，当然你也可以在Op的compute里面检查之类，但是这个ShapeFn有一个点是可以让tesorflow不用执行操作就能获取输入输出信息。在ShapeFn里面你可以拿到输入输出的每一个维度的大小（DimensionHandle），或者属性常量的值或者输入常量的值，然后组合成输出的ShapeHandle，最后调用set_output指定对应输出的shape，同时DimensionHandle是可以做四则运算的。一开始我对如何指定输出大小的api也有一些困惑，因为还涉及动态shape，这里推荐仔细阅读InferenceContext这个类，还是推荐用SourceInsight用好搜索和bookmark即可。 实现Op动手之前了解一下C++中的functor、模板及其特化还是很有必要的，对lambda也有了解的话就更好了，如果你对C++不熟的话建议尽量避免使用Eigen，直接把数组取出来用C计算就行，因为tensorflow里面的张量都是按行主序存的（多维的情况就是最外面的那一维变化最快）。 用C++实现Op有一个固定的套路，遵循这个套路可以避免走弯路，当然这都不是必须的，只要你定义了计算函数并且在kernel的Compute里面调用你的计算即可。初学者可以参考下面这个框架来做： 定义一个Functor模板类做实际的计算工作 针对不同设备甚至不同数据类型特化Functor模板类 定义一个Kernel模板类，继承自OpKernel，在构造函数中根据传进来的OpKernelConstruction设置必要的成员 视情况针对别的设备特化Kernel模板类，一般无需特化，因为这个类里面一般会做一些通用工作，然后将实际的计算转到Functor模板类中 重写Kernel的Compute方法，利用OpKernelContext获取输出，分配输出，并进行合法性检查，然后转调对应的计算Functor 注册Kernel 很多重要的api都在OpKernelConstruction和OpKernelContext两个类里面建议详细阅读。同时Compute方法必须是线程安全的，因此任何对类成员的访问必须要用互斥保护。 在转到实际的计算函数前通常会把输入输出Tensor的缓冲区取出来，要么变成Eigen的表示即TensorMap（其对应的很多成员要去TensorBase里面去找），要么更进一步直接再调用TensorMap的data方法把缓冲区指针取出来传给计算函数。具体地，可以去看Tensor这个类提供的一些接口。 计算的实现过程不细说，可以直接上C，可以用std::thread保证移植性，也可以利用强大的Eigen，里面有很好的并行化机制根据每个执行单元的cost来分配线程资源，还可以利用Tensorflow提供的对Eigen进行包装后的Shard（这个头文件需要自己加）工具类，下面的代码是一个使用示例：123456789auto work_routine = [&amp;your_capture](int64_t start, int64_t limit)&#123; for (int64_t worker_index = start; worker_index &lt; limit; ++worker_index)&#123; // do something &#125;&#125;;const DeviceBase::CpuWorkerThreads&amp; worker_threads = *(context-&gt;device()-&gt;tensorflow_cpu_worker_threads());const int64_t shard_cost = 4 * num_rois;Shard(worker_threads.num_threads, worker_threads.workers, total_elems, shard_cost, work_routine); GPU的实现多数简单情况下GetCudaLaunchConfig + CUDA_1D_KERNEL_LOOP就可以搞定，更多有用的接口可以去看cuda_kernel_helper.h，也可以借助cub的api或者更暴力一点直接写。顺便说一下，使用Eigen或者Tensorflow的CPU并行化机制编写代码，通常写出的代码整体逻辑和GPU代码基本一致，我在写PSROIAlign的时候从CPU代码移植到GPU改动的地方很少。 OpKernel的注册和Ops的注册比较类似，也是调用一个宏REGISTER_KERNEL_BUILDER，指定名称、Kernel对应的设备类型，以及创建这个Kernel的C++类。详见Tensorflow是如何注册和调用C++ New Op的。 创建python接口在这之前当然先要对自己写的Op进行编译，我捣鼓了一个CMakeLists感觉很好用，可以把C++和CUDA代码分开编译然后一起链接很省事，只要正确安装了cuda和python包头文件都可以自己找到，推荐给大家CMakeLists.txt。 编译成功后应该可以获得一个动态库文件 .so，python这边load一下然后包装一下就好了，把官方的示例抄过来：123import tensorflow as tfzero_out_module = tf.load_op_library('./zero_out.so')zero_out = zero_out_module.zero_out 实现Op梯度计算一般就是python这边要么用tensorflow自带Op进行组合，要么再去调用另一个计算梯度的自定义Op，然后整个计算过程放在一个函数里面，用@ops.RegisterGradient修饰一下就行了，具体可参见官方文档。 测试Op同样官方有示例，推荐一个tf.test里面的compute_gradient和compute_gradient_error，很好用。注意这两个函数计算的并不是梯度，而是输出对输入的Jacobian，计算梯度值要用tf.gradients，tf.test中的那两个函数也是基于tf.gradients。其中compute_gradient来计算理论和数值Jacobian，compute_gradient_error计算二者之间的误差。 总结最后总结一下我目前遇到的坑： 最好不要用Eigen接口，除非你对Eigen比较熟，否则建议使用前阅读以下Lazy Evaluation and Aliasing和Common pitfalls 用Shard工具类写CPU端的kernel，方便移植到GPU上，但要注意线程间的同步 全局一致的常量输入使用op的Attr来指定，尤其是需要基于这些常量输入做进一步地运算的时候，因为如果将常量输入作为Scalar类型的Tensor输入，那么在CPU上和GPU上运行时这些输入将在不同的内存里，如果要基于这些常量做进一步地运算在GPU上要用cuda kernel，不利于代码结构的简化 输出记得先清零 暂时想到的就这么多，最后祝大家炼丹顺利~~找到理想工作。","categories":[{"name":"深度学习","slug":"deeplearning","permalink":"https://hikapok.github.io/categories/deeplearning/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://hikapok.github.io/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hikapok.github.io/tags/深度学习/"},{"name":"C++","slug":"C","permalink":"https://hikapok.github.io/tags/C/"}]},{"title":"线性回归和逻辑回归模型的基本假设","slug":"assumption-of-basic-ml","date":"2018-02-28T12:41:59.000Z","updated":"2018-03-01T03:12:14.992Z","comments":true,"path":"2018/02/28/assumption-of-basic-ml/","link":"","permalink":"https://hikapok.github.io/2018/02/28/assumption-of-basic-ml/","excerpt":"","text":"对机器学习刚入门的同学很容易对一些基本概念混淆不清，尤其是当下Python中一些的工具包进一步降低了ML相关的实践。本文重点探讨一下统计学习理论中一些基础模型的应用假设。不过，首先我觉得有必要澄清一些基本概念。 线性模型何为线性模型？看似简单的问题却不一定能答得很好，初学者也容易被数学中线性这一概念所“误导”。 线性回归模型或线性分类器 在本文中这二者较为类似，以线性回归模型为例。给定一组随机抽取的样本$\\mathbf{X_i} = X_{ij}$及其观测值$Y_i$，其中$i=1,…,N$，$j=1,…,p$，$p$是特征维数也是下面公式中非线性基函数的个数，线性回归模型定义为$$Y_i=\\beta_0 + \\beta_1\\phi_1(X_{i1}) + \\cdot + \\beta_p\\phi_p(X_{ip}) + \\varepsilon_i$$其中$\\beta_j$是回归系数，可以用来评估每个分量在预测中的重要性，$\\phi_j$是非线性基函数，$\\varepsilon_t$是回归残差。这里的线性指的是回归系数是$\\beta_j$线性的，同时预测值也是$\\beta_j$的线性组合。 时间序列分析中的线性模型 在基于时间序列的分析和预测中，线性模型指的是某时刻随机变量的预测值是之前若干时刻的随机变量取值的线性函数，通俗来讲就是线性组合。比如随机过程中的一个叫作自回归(Autoregressive, AR)的模型就是一个经典的例子。以$AR(p)$来表示$p$阶自回归模型，则$AR(p)$可定义如下$$ X_t = c + \\sum_{i=1}^p\\varphi _iX_{t-i} + \\varepsilon_t $$其中$\\varphi _1,…,\\varphi _p$是模型参数，$\\varepsilon_t$是残差满足独立高斯分布，$c$是常数项。这里的线性一词并不是指模型参数$\\varphi _i$是线性的，这和线性回归模型是不一样的。 线性回归模型的基本假设现在进入本文正题，注意这里的讨论只针对基本的模型，一些假设可以通过如采样更多的数据，贝叶斯估计或其它正则化等方法进行弱化。 i.i.d.：样本随机独立抽样，也就是机器学习问题中最基本的独立同分布假设，训练样本和测试样本必须来自同一个潜在数据生成分布 解释分量之间不满足多重共线性，同时样本数不能太少：这两点就能保证设计矩阵$\\mathbf{X}$是满秩的（样本数要大于解释分量数），这样$\\mathbf{X}^T\\mathbf{X}$就有唯一的逆矩阵，这在线性回归的最小平方估计方法中非常重要，保证了回归系数的唯一性。 Error-Free：样本$\\mathbf{X_i}$采样过程中没有引入其他噪声，换句话说除了$\\mathbf{X_i}$没有其它未知变量可以对$Y_i$对应的真实值产生确定性的影响，违反这一假设所引入的误差称为贝叶斯误差（Bayes error） 回归误差的条件均值为零：这一点其实和上面的是一样的，同样意味着$\\mathbf{X_i}$中包含了所有可以解释$Y_i$的分量，即$E[\\varepsilon|\\mathbf{X}] = 0$ 线性假设：预测真实值是回归系数的线性组合 回归误差的方差一致性：回归误差在不同真实值处应具有相同的方差，与$\\mathbf{X_i}$及$Y_i$无关，即$Var(\\varepsilon|\\mathbf{X})=\\sigma^2$ 回归误差的独立性：承接上一条，$\\varepsilon_i$之间应是相互独立的，$\\varepsilon \\sim N(0,\\sigma^2)$，即不取决于是哪一个样本，至于零均值满足第四条自然能够得出 逻辑回归模型的基本假设 i.i.d.：同上 解释分量之间不满足多重共线性：观察迭代重加权最小平方的公式可以发现与线性回归模型中的这一点类似 对数几率和解释变量之间存在线性关系：保证了回归系数是线性的","categories":[{"name":"机器学习","slug":"machinelearning","permalink":"https://hikapok.github.io/categories/machinelearning/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://hikapok.github.io/tags/机器学习/"},{"name":"统计学习","slug":"统计学习","permalink":"https://hikapok.github.io/tags/统计学习/"}]},{"title":"手把手教你用Google云平台搭建自己的深度学习工作站","slug":"intro-to-google-cloud","date":"2018-01-19T08:11:40.000Z","updated":"2018-03-01T02:59:37.913Z","comments":true,"path":"2018/01/19/intro-to-google-cloud/","link":"","permalink":"https://hikapok.github.io/2018/01/19/intro-to-google-cloud/","excerpt":"","text":"Hello，大家好，最近正式启用了自己的博客，一直以来被各种任务缠身，始终没有养成记录自己学习的点滴的习惯。最近忙于申请实习拿到了两个还不错的offer，但无奈导师坚决不放人，于是打算接下来做一些别的事情，输出一些质量高的博文就是其中一项。 自己也算是入行计算机挺久了，一路走来有许多的感慨，包括个人的选择成长规划等等，过段时间也会进行一下总结分享给大家，希望大家能少走弯路。 第一篇博文专注于利用较少的资金建立一个可以用于深度学习调试的小工作站，从整体上来看谷歌云（Google Cloud Platform，GCP）在这价格、稳定性等方面有很大的优势，但是好像并没有多少介绍这方面的文章，作为新手来讲熟悉这些配置可能要花上一两天，这篇博文目的就是让新手在半小时内配置一个可用的深度学习环境，涉及配置的各种细节以及开发过程的各个方面，欢迎大家一起交流讨论。 原材料准备： 支持VISA双币支付的信用卡一张 科学上网工具 PuTTY或其他终端工具 FileZilla或其他支持SFTP的客户端 注册首先你需要有一个Google账户，然后登陆https://cloud.google.com/点击免费试用进行注册，填写基本信息和相关协议，账户类型选择个人，地址注意与信用卡账单地址一致，注册完成后信用卡账户会被预扣1美元，过会就会返还回来的。 创建项目GCP对资源进行层次化的管理，方便结合Cloud Identity and Access Management (IAM)进行权限控制和统一配置，大到公司部门，小到具体某个虚拟机。对于个人用户来说，我们通常只需按照项目来组织我们的资源，项目可以说是我们创建、管理和监控资源、进行权限管理以及账单管理的基本单位了，新建账户默认包含一个初始项目，你也可以在控制台创建自己的新项目（个人用户默认最多10个项目），假设现在你已经配置好了自己的项目。 GCP有很多产品，包括大数据平台，存储和数据库服务，AI相关的API等，来帮助企业更快地创建优质的应用，但这些与本文无关，本文集中介绍如何利用Compute Engine Virtual Machines (VMs)来创建一个较为廉价的可供日常学习使用的机器学习/深度学习平台，合理利用这些资源可以让你尽可能少地为高昂的显卡资源自掏腰包。在正式开始之前有以下几点需要说明一下： 快捷入口：控制台左侧的Tab提供了GCP产品的一些快捷入口，本文主要涉及计算（Compute Engine）、网络（VPC网络）、产品（结算、IAM和管理）和存储（存储），可以先将这些入口钉一下固定在最上面方便一会直接点进去。 预算：作为穷学生一枚本人比较关心钱的问题，虽然有Google赠送的300美元的现金券，我还是一开始就为整个项目（或者以整个计算账号为单位）制定了预算，超出时会自动提醒。费用是每天更新一次，结算周期是半个月，Google会在你花超过100美元或者距上次缴费超过一个月后自动扣款，费用详情可以在结算/交易里查询。 配额：由于每个账号所拥有的资源都有一定的配额，并且GCP默认的GPU配额是0，因此我们需要进行配额调整的申请。具体在IAM和管理/配额里面操作，见图，点击指标下拉框搜索NVIDIA就会看到K80、P100等型号的GPU，把其他资源都反选掉，只保留GPU相关的服务。然后在下面列表里勾选你要选用的GPU型号（注意区域要和待会要创建的VMs所在区域一致），型号根据自己情况进行选择，本人选了K80（12GB内存可以满足我的日常使用），然后选择最上面的修改配额，在右侧弹窗里输入个人电话，目标调整数量以及申请理由，提交即可，我大概等了不到10分钟就调整好了。 创建虚拟机创建VMs相关的操作都在Compute Engine菜单下，为了节省费用同时不至于太影响训练速度，我只设置了30GB的永久固态硬盘，然后又创建了120GB的永久机械硬盘挂载到实例上。如果你只希望用固态硬盘当做启动盘和数据盘，可以忽略创建磁盘这一步。 创建磁盘Compute Engine/磁盘：点击最上面创建磁盘，输入名称，选择与VMs一致的地区，类型设置为标准永久性磁盘，土豪可以选择SSD永久性磁盘，由于初次使用没有映像或者快照，因此来源类型选无（空白磁盘），待会我们在VMs里面进行格式化和分区操作。大小根据自己需求，建议可以稍大一些，一方面性能会好一些，另一方面各种数据集通常都要来回捣腾，因此最好要比预期数据量大一倍。 创建VMsCompute Engine/VM实例：点创建，输入名称，这个名称会作为计算机名，选择与GPU和磁盘一致的区域，机器类型勾选自定义，我选的是4vCPU、8GB内存、1个K80 GPU，详单见图。启动磁盘选更改进行配置，选择Ubuntu 16.04 LTS操作系统镜像，如果我们之前对自己创建的虚拟机备份过映像这里可以直接选上，启动磁盘类型建议选择SSD大小自己配置，如果你之前有删除实例后剩下的启动磁盘想直接用可以在现有磁盘下面勾选，前提是里面要有操作系统。 防火墙一栏勾上允许HTTP流量和HTTPS流量。下方磁盘那个Tab可以设置是否在删除实例时也把启动盘删除，这里我们在额外磁盘下面选择添加一项把之前创建的数据磁盘挂上来。管理Tab里面可以设置启动脚本，方便每次开机时进行系统更新、外部磁盘挂载等操作，这里我先没有设置，因为后面可以在弄好机器后在更改元数据里面重新设置。此外如果你不需要长时间训练模型那么可以开启抢占式VM，缺点就是随时都可能被终止（大约10%~20%的概率，实际由对应区域用量决定），即使由于整个区域用量较小没有被停掉24小时之后也会被终止，如果刚开启虚拟机10分钟之内被抢占是不收费的，需要注意的是抢占式VM的资源总量是有限的，也就是说并不是什么时候想用什么时候就有。 SSH密钥那个Tab里面我们需要配置一下以便使用其它终端工具对VM进行操作，GCP也自带基于浏览器的一种终端，感觉也不错，但是比较慢。终端工具根据自己习惯选择，这里以PuTTY为例进行配置。PuTTY带有一个密钥生成工具PuTTYgen，打开界面如下： 点击generate然后在空白区域来回晃几下鼠标就会生成一个ssh-rsa密钥，comment改成自己的用户名，VM会自动创建对应的账户，然后复制Public key（就是以ssh-rsa开头的最长的那个）粘贴到GCP刚才那个Tab里面，点创建等几分钟即可。接下来我们需要把刚才生成的密钥保存在同一个目录，保存private key的时候会提示设置密码。保存完毕后需要打开PuTTY新建一个session，这会VM实例应该也创建完毕，把外部ip地址填进来，然后在Connection-&gt;SSH-&gt;Auth属性页最下面把保存的private key加载进来，最后打开连接，安全提示选是然后就可以连接到虚拟机了。 如果你想直接用在线的SSH的话，直接在Compute Engine/VM实例里面点SSH，可以通过这个工具上传下载一些简单的文件之类的。 设置数据磁盘 数据磁盘本身是空白磁盘，虽然被接进来了，但必须进行格式化分区之后才可以挂载。以下命令帮你查看数据磁盘是不是真的连接进来了，并查看对应的设备号，我这里是sdb。 1sudo fdisk –l 接下来我们需要对空白磁盘进行分区，同样是使用fdisk命令进入一个交互式的环境，这个环境下所有的操作都不会立刻写进分区表，除非显式地通过w保存操作： 1sudo fdisk /dev/sdb 根据相应的快捷键提示可以很容易完成分区，我的整个磁盘只有一个分区，如果你的磁盘很大也可以分多个区，n新建分区，d删除分区，w保存分区表，q不保存直接退出。 如果你也是只分了一个区，那么你应该会得到一个名为sdb1的新设备，下面命令完成格式化，你也可以换成ntfs格式，这里使用linux格式： 1sudo mkfs.ext4 /dev/sdb1 接下来我们在/media目录下新建一个挂载点（我这里名称为disk），把刚才格式化好的设备挂载进来： 12sudo mkdir /media/disksudo mount /dev/sdb1 /media/disk 如果你不想每次开机都手动挂载这个设备的话，可以设置上面说到的那个启动脚本，启动脚本的设置需要在关机状态下进行，待会你重启时记得设置：仍然是在Compute Engine/VM实例下面，点击VM的名称进入VM详情页面，点击最上面修改，往下拉找到自定义元数据，键设为startup-script，值设置为下面的脚本内容，然后点保存重启虚拟机。 12#! /bin/bashmount /dev/sdb1 /media/disk 同样的方法也可以设置shutdown-script，可以在关机或被抢占时保存模型或给自己发个邮件提醒之类的。 以上步骤完成后，我们还需要设置一下防火墙： 网络/VPC网络/防火墙规则：然后点击最上面创建防火墙规则，名称default-dev之类，目标选网络中的所有实例，来源 IP 地址范围填0.0.0.0/0，协议和端口填tcp:6000-6010;tcp:8888（这个根据日常开发用到的端口自己决定），其他保持默认。 环境配置现在你已经有了一台至少4核8G内存附带一张K80显卡的机器了，接下来就是跟普通机器一样配置环境了。如果你已经很熟悉深度学习之类的环境配置，可以直接跳过这一部分。 我通常先会按照自己的使用习惯配置一下tmux、git和vim，装一些插件之类的。下面的命令可以帮你把一些大概率会用到的包提前装上，以免后续安装过程卡壳： 1sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev valgrind cmake unrar gfortran python3-pip python3-dev python3-wheel swig git git-core htop 建议日常的机器学习之类的调试训练都在虚拟环境下进行，虚拟环境配置可以参考下面命令： 1234sudo apt-get install python-pip python-setuptoolssudo pip install --upgrade pipsudo pip install virtualenvcurl -L https://raw.github.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 设置虚拟环境对应的环境变量 1sudo vim ~/.bash_profile 在文件最后加上下面这些内容： 123export PATH=\"/home/yourname/.pyenv/bin:$PATH\"eval \"$(pyenv init -)\"eval \"$(pyenv virtualenv-init -)\" 生效更改然后安装python 3.5.2： 12source ~/.bash_profilepyenv install 3.5.2 注意把默认的python设置为系统对应的python版本 1234# 查看可用的python版本，注意默认版本pyenv versions# 把默认版本设为系统自带的python版本pyenv global system 在当前目录下创建一个名为pyenv35的虚拟环境 1virtualenv -p .pyenv/versions/3.5.2/bin/python3.5 pyenv35 激活刚创建的虚拟环境 1source pyenv35/bin/activate 安装常用机器学习包（这个根据自己的需求来） 1pyenv35/bin/pip3.5 install numpy scipy matplotlib pandas seaborn sklearn lightgbm xgboost tqdm 安装CUDA运行时环境 首先确认一下系统应该至少没有安装除nvidia-common之外的任何nvidia的包： 1dpkg -l | grep -i nvidia 否则使用以下命令删除多余的包及配置文件： 12sudo apt-get remove --purge name_of_ packagesudo apt-get autoremove 然后我们需要下载CUDA的安装包和cuDNN： 123sudo wget http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_8.0.61-1_amd64.debsudo wget http://developer.download.nvidia.com/compute/redist/cudnn/v6.0/cudnn-8.0-linux-x64-v6.0.tgzsudo wget https://developer.nvidia.com/compute/cuda/8.0/Prod2/patches/2/cuda-repo-ubuntu1604-8-0-local-cublas-performance-update_8.0.61-1_amd64-deb 接下来安装驱动和运行时： 123sudo dpkg -i cuda-repo-ubuntu1604_8.0.61-1_amd64.debsudo dpkg -i cuda-repo-ubuntu1604-8-0-local-cublas-performance-update_8.0.61-1_amd64.debsudo apt-get update 查看可用的CUDA运行时版本： 1sudo apt-cache policy cuda 安装CUDA8.0 1sudo apt-get install cuda=8.0.61-1 添加源并更新到最新驱动： 1sudo add-apt-repository ppa:graphics-drivers/ppa 这里记得需要敲回车键确认添加源 123sudo apt-get updatesudo apt-get upgradesudo reboot 安装cuDNN 1234tar -xvf cudnn-8.0-linux-x64-v6.0.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 设置环境变量： 1sudo vim ~/.bashrc 在文件最后添加下面内容： 123export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64\"export CUDA_HOME=/usr/local/cudaexport PATH=\"$CUDA_HOME/bin:$PATH\" 生效更改 1source ~/.bashrc 最后敲nvidia-smi确认驱动安装成功 安装深度学习工具包安装bazel、tensorflow-gpu、PyTorch、MxNet 1234sudo apt-get install openjdk-8-jdkecho \"deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8\" | sudo tee /etc/apt/sources.list.d/bazel.listcurl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -sudo apt-get update &amp;&amp; sudo apt-get install bazel 先进入虚拟环境，然后执行以下命令安装： 1pyenv35/bin/pip3.5 install opencv-python tensorflow-gpu http://download.pytorch.org/whl/cu80/torch-0.3.0.post4-cp35-cp35m-linux_x86_64.whl torchvision mxnet-cu80==1.0.0 配置远程jupyter notebook 仍然是在虚拟环境下，安装notebook: 1pyenv35/bin/pip3.5 install jupyter notebook 进入python交互式环境，生成hash密码： 12from notebook.auth import passwdpasswd() 输入密码并记下形如’sha1:daa96*06c24059c807b08’的字串。 在bash里输入下面的命令生成notebook配置文件 1jupyter notebook --generate-config 编辑配置文件，设置密码和权限等： 1sudo vim .jupyter/jupyter_notebook_config.py 设置以下几项并保存： 1234c.NotebookApp.ip = '*'c.NotebookApp.password = u'sha1:daa96*06c24059c807b08'c.NotebookApp.open_browser = Falsec.NotebookApp.port = 8888 执行jupyter notebook打开notebook，然后在本地浏览器打开http://yourip:8888，如果正常的话，输入密码就可以使用了。如果有问题可以确认一下防火墙。 现在是时候去网上找一些测试代码来确认安装过程的正确性了。 文件共享本想按照往常一样安装samba将虚拟机的磁盘映射到windows系统网络驱动器来传文件，但是搞了半天老是连不通，有知道解决方案的知友欢迎留言。因此目前只能采用FileZilla通过SFTP给VMs传文件的方式。操作如下： 打开FileZilla-&gt;文件-&gt;站点管理器-&gt;新站点：主机填VM的外部ip，协议选择SFTP，登录类型选择密码文件，然后把之前用PuTTY生成的私钥加载进来，高级选项卡里面可以设置本地目录和远程目录。最后点连接就行了，如果有问题的话可以检查一下远程目录的权限，我试了一下传输速度还挺快。 还有一点，日常的开发工作除了用notebook远程连接外，还可以在SublimeText下面使用SFTP的插件，配置过程跟上面文件传输的配置类似。 好了现在就应该都大功告成了，最后别忘了为配置好的系统制作映像，以便将来重新安装： Compute Engine-&gt;映像-&gt;创建映像。 最近会抽空更新几篇机器学习相关的文章，欢迎大家关注，也欢迎大家讨论交流、指出问题。","categories":[{"name":"其它","slug":"others","permalink":"https://hikapok.github.io/categories/others/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://hikapok.github.io/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hikapok.github.io/tags/深度学习/"},{"name":"环境配置","slug":"环境配置","permalink":"https://hikapok.github.io/tags/环境配置/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-16T08:42:43.371Z","updated":"2017-10-02T15:52:19.000Z","comments":true,"path":"2017/10/16/hello-world/","link":"","permalink":"https://hikapok.github.io/2017/10/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}